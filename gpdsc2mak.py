#!/usr/bin/python
#
# This is the PUBLIC DOMAIN converter from the gpdsc files
# generated by the STM32CubeMX to the GCC Makefile,
# Written by Wojciech M. Zabolotny (wzab<at>ise.pw.edu.pl)
# This is the first "proof of the concept" implementation
# I don't give you any warranty! You use it at your own risk
# It happened to work for me with my simplistic project,
# generated by STM32CubeMX for FreeRTOS, with slightly
# modified StartDefaultTaskFunction.
# I compiled it with debian gcc-arm-none-eabi tools
# and run/debugged with stlink (https://github.com/texane/stlink)
# and debian gdb-arm-none-eabi
# The linker script STM32L100RCTx_FLASH.ld was taken from the
# STM32Cube_FW_L1_V1.4.0 firmware
#
import xml.etree.ElementTree as et
import os
import sys

#Additional options for the compiler
#Please note, that maybe it should be also somehow
#extracted from the gpdsc file?
extras="-mthumb -mcpu=cortex-m3 --specs=nosys.specs -D STM32L100xC -T STM32L100RCTx_FLASH.ld -g "

class project(object):
  def __init__(self):
    self.sfiles=[]
    self.headers=[]
    self.includes=[]

  def fproc(self,fdesc):
    print fdesc.attrib['category']+":"+fdesc.attrib['name']
    #If the file contains attribute 'condition' and it
    #is NOT set to 'GCC Toolchain', then ignore it
    if fdesc.attrib.has_key('condition') and \
       fdesc.attrib['condition'] != 'GCC Toolchain':
       print "Ignored"
       return
    #Analyse different categories
    if fdesc.attrib['category']=='header':
       #This is a header file, so we extract its directory
       #and add it to list of includes
       #Change crazy MS backslashes into standard slashes
       fpath=fdesc.attrib['name'].replace('\\','/')
       idir=os.path.dirname(fpath)
       self.headers.append(fpath)
       self.includes.append(idir)
    if fdesc.attrib['category']=='sourceC' or \
       fdesc.attrib['category']=='source' or \
       fdesc.attrib['category']=='sourceAsm':
       #Change crazy MS backslashes into standard slashes
       fpath=fdesc.attrib['name'].replace('\\','/')
       self.sfiles.append(fpath)

descfile=et.ElementTree(file=sys.argv[1])
proj=project()
rt=descfile.getroot()
#Handle the files defined in the "generators" section
for c1 in rt.findall('generators'):
  print c1
  for c2 in c1.findall('generator'):
   print c2
   for c3 in c2.findall('project_files'):
    print c3
    for c4 in c3.findall('file'):
      proj.fproc(c4)
#Handle the files defined in the "componments section
for c1 in rt.findall('components'):
  print c1
  for c2 in c1.findall('component'):
   print c2
   for c3 in c2.findall('files'):
    print c3
    for c4 in c3.findall('file'):
      proj.fproc(c4)
#Now we can generate the makefile
fmak=open("Makefile","wt")
#Write the headers
fmak.write("HEADERS=\\\n")
for f in proj.headers:
  fmak.write("   "+f+"\\\n")
#End headers
fmak.write("\n")

#Write the sources
fmak.write("SOURCES=\\\n")
for f in proj.sfiles:
  fmak.write("   "+f+"\\\n")
#End sources
fmak.write("\n")

#Create the CFLAGS
fmak.write("CFLAGS=\\\n")
for f in proj.includes:
  fmak.write("  -I "+f+"\\\n")
#End CFLAGS definition
fmak.write("\n")

#Create the target
fmak.write("prog : ${HEADERS} ${SOURCES}\n")
fmak.write("\tarm-none-eabi-gcc "+extras+" ${CFLAGS} -o prog ${SOURCES}\n")

